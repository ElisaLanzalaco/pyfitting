import numpy as np
from scipy.stats import norm, chi2
import matplotlib.pyplot as plt

#==============================================================================#
class VariabilityAssessment(object):
    """ Class meant to evaluate the hypothesis zero of variance from 
    synthetic data generated by a Gaussian distribution around the model. """

#------------------------------------------------------------------------------#
    def BootstrapingUni(self, x, y, param0, param1, low_bound, up_bound, 
            residual, model, around_func=True):

        bounds = Bounds(low_bound,up_bound)
        param_bool = ~np.isclose(low_bound,up_bound)

        nparam = param0.shape[0]
        mfit = np.sum(param_bool)

        ndata = x.shape[0]
        conf = 0.95
        nboot = 100

        # creates bootstrap residuals
        boot_res = np.random.choice(residual,(nboot,ndata))
        boot_y = np.zeros((nboot,ndata),dtype=np.float64)
        boot_opt0 = np.zeros((nboot,nparam),dtype=np.float64)
        boot_opt = np.zeros((nboot,mfit),dtype=np.float64)
        if around_func:
            for i in range(nboot):
                boot_y[i,:] = boot_res[i,:] + model.funcs(x,*param1)
                boot_opt0[i,:] = CurveFit(x, boot_y[i,:], param0, 
                        low_bound, up_bound, model, bootstrap=True)
        else:
            for i in range(nboot):
                boot_y[i,:] = boot_res[i,:] + y
                boot_opt0[i,:] = CurveFit(x, boot_y[i,:], param0, 
                        low_bound, up_bound, model, bootstrap=True)

        boot_opt[:,:] = boot_opt0[:,param_bool]
        boot_mean = np.mean(boot_opt,axis=0)
        boot_std = np.std(boot_opt, axis=0, ddof=1)
        boot_cov = np.cov(boot_opt.transpose())

        print("\n***********************************************************************\n")
        print("Bootstraping results:\n")
        print("Bootstrap mean = {}".format(boot_mean))
        print("Bootstrap std = {}".format(boot_std))

        z = np.linspace(boot_mean-3.*boot_std,boot_mean+3.*boot_std,100)

        # assumed normal distribution for bootstrap data
        dist0 = norm(loc=boot_mean, scale=boot_std)
        interval0 = dist0.interval(conf)
        p_value0 = dist0.cdf(param1[param_bool])
        for i in range(p_value0.shape[0]):
            if p_value0[i] > 0.5:
                p_value0[i] = 2.0*(1.0 - p_value0[i])
            else:
                p_value0[i] = 2.0*p_value0[i]

        # boot_mean + norm(conf)*boot_std
        print("\nSeparate confidence interval ({}) ".format(conf*100.) +\
              "= \n{}".format(interval0))
        print("The p-values are = {}".format(p_value0))

        # multivariate test
        dist3 = chi2(mfit)
        diff = boot_mean - param1[param_bool]
        if mfit != 1:
            boot_cov_inv = np.linalg.inv(boot_cov)
            z_square = np.einsum('i,ij,j',diff,boot_cov_inv,diff)
        else:
            boot_cov_inv = 1.0/boot_cov
            z_square = boot_cov_inv*diff**2
        print("\nZ-squared (multivariate test) = {}".format(z_square))
        print("chi-squared at {} ".format(100.*conf) +\
          "= {}".format(dist3.ppf(conf)) )
        print("P-value of test = {}".format(1.-dist3.cdf(z_square)))

        factor = nboot*boot_std/np.sqrt(ndata)
        fig, ax = plt.subplots(2,mfit, figsize=plt.figaspect(1.0/mfit))

        if mfit != 1:
            for i in range(mfit):
                # data distribution
                ax[0,i].hist(boot_opt[:,i], bins=15)
                ax[0,i].plot(z[:,i], factor[i]*dist0.pdf(z)[:,i])
                # QQplot for error 1
                sm.graphics.qqplot(boot_opt[:,i], line='s', ax=ax[1,i])
        else:
            # data distribution
            ax[0].hist(boot_opt[:,i], bins=15)
            ax[0].plot(z[:,i], factor[i]*dist0.pdf(z)[:,i])
            # QQplot for error 1
            sm.graphics.qqplot(boot_opt[:,i], line='s', ax=ax[1])

        fig.tight_layout()
        plt.show
        FIGURENAME = 'bootstrap.pdf'
        plt.savefig(FIGURENAME)
        plt.close('all')

        fig, ax = plt.subplots()

        # data distribution
        for i in range(nboot):
            ax.scatter(x, boot_y[i,:])
        ax.plot(x, y, marker='*', color='red', label='exp')
        ax.plot(x, model.funcs(x, *param1), label='fit')
        ax.set_ylim(bottom=0) #,top=250
        ax.set_xlim(left=1.0) #,right=1.17
        ax.legend(loc='upper left')

        fig.tight_layout()
        plt.show
        FIGURENAME = 'bootstrap_fit.pdf'
        plt.savefig(FIGURENAME)
        plt.close('all')

#------------------------------------------------------------------------------#
    def BootstrapingMulti(self, x, y, param0, param1, low_bound, up_bound,
            residual, model, around_func=True):

        bounds = Bounds(low_bound,up_bound)
        param_bool = ~np.isclose(low_bound,up_bound)

        nparam = param0.shape[0]
        mfit = np.sum(param_bool)

        ndata = x.shape[0]
        nfunc = y.shape[1]
        conf = 0.95
        nboot = 100

        # creates bootstrap residuals
        boot_res = np.zeros((nboot,ndata,nfunc),dtype=np.float64)
        for i in range(nfunc):
            boot_res[:,:,i] = np.random.choice(residual[:,i],(nboot,ndata))
        boot_y = np.zeros((nboot,ndata,nfunc),dtype=np.float64)
        boot_opt0 = np.zeros((nboot,nparam),dtype=np.float64)
        if around_func:
            for i in range(nboot):
                boot_y[i,:,:] = boot_res[i,:,:] + model.funcs(x, *param1)
                boot_opt0[i,:] = CurveFit(x, boot_y[i,:,:], param0, 
                        low_bound, up_bound, model, bootstrap=True)
        else:
            for i in range(nboot):
                boot_y[i,:,:] = boot_res[i,:,:] + y
                boot_opt0[i,:] = CurveFit(x, boot_y[i,:,:], param0, 
                        low_bound, up_bound, model, bootstrap=True)

        boot_opt = boot_opt0[:,param_bool]
        boot_mean = np.mean(boot_opt,axis=0)
        boot_std = np.std(boot_opt, axis=0, ddof=1)
        boot_cov = np.cov(boot_opt.transpose())

        print("\n***********************************************************************\n")
        print("Bootstraping results:\n")
        print("Bootstrap mean = {}".format(boot_mean))
        print("Bootstrap std = {}".format(boot_std))

        z = np.linspace(boot_mean-3.*boot_std,boot_mean+3.*boot_std,100)

        # assumed normal distribution for bootstrap data
        dist0 = norm(loc=boot_mean, scale=boot_std)
        interval0 = dist0.interval(conf)
        p_value0 = dist0.cdf(param1[param_bool])
        for i in range(p_value0.shape[0]):
            if p_value0[i] > 0.5:
                p_value0[i] = 2.0*(1.0 - p_value0[i])
            else:
                p_value0[i] = 2.0*p_value0[i]

        # boot_mean + norm(conf)*boot_std
        print("\nSeparate confidence interval ({}) ".format(conf*100.) +\
              "= \n{}".format(interval0))
        print("The p-values are = {}".format(p_value0))

        # multivariate test
        dist3 = chi2(mfit)
        diff = boot_mean - param1[param_bool]
        if mfit != 1:
            boot_cov_inv = np.linalg.inv(boot_cov)
            z_square = np.einsum('i,ij,j',diff,boot_cov_inv,diff)
        else:
            boot_cov_inv = 1.0/boot_cov
            z_square = boot_cov_inv*diff**2
        print("\nZ-squared (multivariate test) = {}".format(z_square))
        print("chi-squared at {} ".format(100.*conf) +\
          "= {}".format(dist3.ppf(conf)) )
        print("P-value of test = {}".format(1.0-dist3.cdf(z_square)))

        factor = nboot*boot_std/np.sqrt(ndata)
        fig, ax = plt.subplots(2,mfit, figsize=plt.figaspect(1./float(mfit)))

        if mfit != 1:
            for i in range(mfit):
                # data distribution
                ax[0,i].hist(boot_opt[:,i], bins=15)
                ax[0,i].plot(z[:,i], factor[i]*dist0.pdf(z)[:,i])
                # QQplot for error 1
                sm.graphics.qqplot(boot_opt[:,i], line='s', ax=ax[1,i])
        else:
            # data distribution
            ax[0].hist(boot_opt[:,i], bins=15)
            ax[0].plot(z[:,i], factor[i]*dist0.pdf(z)[:,i])
            # QQplot for error 1
            sm.graphics.qqplot(boot_opt[:,i], line='s', ax=ax[1])

        fig.tight_layout()
        plt.show
        FIGURENAME = 'bootstrap.pdf'
        plt.savefig(FIGURENAME)
        plt.close('all')

        fig, ax = plt.subplots()

        # data distribution
        for i in range(nboot):
            ax.scatter(x, boot_y[i,:,:])
        ax.plot(x, y, marker='*', color='red', label='exp')
        ax.plot(x, model.funcs(x, *param1), label='fit')
        ax.set_ylim(bottom=0) #,top=250
        ax.set_xlim(left=1.0) #,right=1.17
        ax.legend(loc='upper left')

        fig.tight_layout()
        plt.show
        FIGURENAME = 'bootstrap_fit.pdf'
        plt.savefig(FIGURENAME)
        plt.close('all')


